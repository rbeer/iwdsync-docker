#/usr/bin/env bash

# use experimental BuildKit to enable
# --mount at RUN in Dockerfiles, enabling
# caching of pip packages
#  !! Requires Docker v18.09 or later
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1

COMPOSE_FILE="iwdlive-dev_postgres_www.yml"

API_REPO_PATH="../iwdsync-backend"
API_REPO_GIT_DIR="$API_REPO_PATH/.git"
API_REPO_REMOTE="../../stream-sync/iwdsync-backend/.git"

PWA_REPO_PATH="../iwdsync"
PWA_REPO_GIT_DIR="$PWA_REPO_PATH/.git"
PWA_REPO_REMOTE="../../stream-sync/iwdsync/.git"
# branch to check out when cloning API and PWA
GIT_BRANCH="docker-dev"

# Services to build images for
# Essentially all services that have
# a build: entry in the $COMPOSE_FILE
BUILD_IMAGE_FOR="api pwa www"

# Services to run detached, after successful init
AUX_SERVICES="db redis www"
# Domain to set up (used for e.g. SSL certificate)
# REMEMBER to point this to 127.0.0.1 in your DNS or hosts file!
CERT_DOMAIN="iwdlive.dev"

# other settings
COLOR_FG_CYAN="\e[38;5;159m"
COLOR_FG_RED="\e[38;5;196m"
COLOR_FG_YELLOW="\e[38;5;226m"
COLOR_FG_GREEN="\e[38;5;46m"
COLOR_RESET="\e[0m"

function print_init_steps {
  echo "--- iwdlive docker development setup ---"
  echo "This script will"
  echo "  1. Clone the API service ($GIT_BRANCH branch) to $API_REPO_PATH"
  echo "  2. Clone the PWA service ($GIT_BRANCH branch) to $PWA_REPO_PATH"
  echo "  3. Build images ($BUILD_IMAGE_FOR)"
  echo "  4. Create the certificate for $CERT_DOMAIN (requires mkcert)"
  echo "  5. Migrate API db schemas"
  echo "  6. Create a django superuser"
  echo -e "----------------------------------------"
  read -p "Key to continue..."
}

function print_banner_border {
  printf '#%.0s' `seq $1`; printf '\n'
}

function print_banner {
  local TITLE="$1 $COLOR_FG_CYAN$2$COLOR_RESET"
  local TITLE_LENGTH=${#TITLE}
  local DIVIDER_LENGTH=$(($TITLE_LENGTH + 4))

  echo ""
  print_banner_border $DIVIDER_LENGTH
  echo -e "# $TITLE"
  print_banner_border $DIVIDER_LENGTH
}

function print_error {
  echo -e "$COLOR_FG_RED!! $1$COLOR_RESET"
}

function print_warning {
  echo -e "${COLOR_FG_YELLOW}$1$COLOR_RESET"
}

function bail_on_fail {
  if [ $1 -ne 0 ]; then
    print_error "Can't proceed without $2. Please check output above for errors!"
    exit $1
  fi
}

###
# 'mkcert' <DOMAIN>
###
function make_certificate() {
  which mkcert &> /dev/null
  if [ $? -ne 0 ]; then
    echo "You need mkcert for certificate management!"
    echo "Download from: https://github.com/FiloSottile/mkcert"
    [ "$2" != "init" ] && exit 1
  fi

  local DOMAIN=$1
  local OUT_PATH=./www/ssl/$DOMAIN

  mkdir -p $OUT_PATH

  mkcert \
    -key-file $OUT_PATH/key.pem \
    -cert-file $OUT_PATH/cert.pem \
    $DOMAIN *.$DOMAIN
}

###
# pre-run checks
###

function check_docker_daemon {
  docker ps &>/dev/null
  if [ $? -ne 0 ]; then
    print_error "No Docker service running."
    exit 1
  fi
}

function check_empty_parent {
  local HAS_MISC_DIRS=0
  for DIR_NAME in ".."/*; do
    if [ $DIR_NAME != "../docker" ]; then
      HAS_MISC_DIRS=1
      break
    fi
  done

  if [ $HAS_MISC_DIRS -eq 1 ]; then
    print_warning "The parent directory is not empty."
    read -p "Proceed with non-empty parent? [y/N] " USE_NON_EMPTY_PARENT
    if [ "$USE_NON_EMPTY_PARENT" != "y" ]; then exit 0; fi
  fi
}

function check_docker_version {
  local CHECK_FAILED=0
  local MIN_VERSION_MAJOR=18
  local MIN_VERSION_MINOR=09
  local MIN_VERSION="$MIN_VERSION_MAJOR.$MIN_VERSION_MINOR"

  local DOCKER_VERSION=`docker version --format '{{.Server.Version}}'`
  local DOCKER_VERSION_MAJOR=$((${DOCKER_VERSION:0:2}))
  local DOCKER_VERSION_MINOR=$((${DOCKER_VERSION:3:2}))

  echo "  Required: $MIN_VERSION"
  echo "  Installed: $DOCKER_VERSION"

  [ $DOCKER_VERSION_MAJOR -lt $MIN_VERSION_MAJOR ] && \
    CHECK_FAILED=1

  [ $DOCKER_VERSION_MAJOR -eq $MIN_VERSION_MAJOR ] && \
    [ $DOCKER_VERSION_MINOR -lt $MIN_VERSION_MINOR ] && \
      CHECK_FAILED=1

  if [ $CHECK_FAILED -eq 1 ]; then
    print_error "Please upgrade to or install Docker v$MIN_VERSION or later!"
    exit 1
  fi
  echo ""
}

###
# 1. Clone the API service
###
function init_api_repo {
  local GIT_DIR_PATH_ABSOLUTE=`realpath $API_REPO_GIT_DIR 2> /dev/null`
  GIT_DIR=$GIT_DIR_PATH_ABSOLUTE git branch &> /dev/null
  if [[ $? == 0 && $GIT_DIR_PATH_ABSOLUTE != "" ]]; then
    echo "API repo already present at $GIT_DIR_PATH_ABSOLUTE"
  else
    git clone --single-branch -b $GIT_BRANCH $API_REPO_REMOTE $API_REPO_PATH
  fi
}

###
# 2. Clone the PWA service
###
function init_pwa_repo {
  local GIT_DIR_PATH_ABSOLUTE=`realpath $PWA_REPO_GIT_DIR 2> /dev/null`
  GIT_DIR=$GIT_DIR_PATH_ABSOLUTE git branch &> /dev/null
  if [[ $? == 0 && $GIT_DIR_PATH_ABSOLUTE != "" ]]; then
    echo "PWA repo already present at $GIT_DIR_PATH_ABSOLUTE"
  else
    git clone --single-branch -b $GIT_BRANCH $PWA_REPO_REMOTE $PWA_REPO_PATH
  fi
}

###
# 3. Build the images for $BUILD_IMAGE_FOR
###
function build_images {
  docker-compose -f $COMPOSE_FILE build $BUILD_IMAGE_FOR
  bail_on_fail $? "images"
}

###
# Bring up services detached
###
function up_d_services {
  docker-compose -f $COMPOSE_FILE up -d $1
  bail_on_fail $? "auxiliary services"
}

function await_db {
  local QUERY=1
  local PG_READY_STATUS

  while true; do
    sleep $(($QUERY * 1))
    echo -n "[$QUERY/âˆž] pg_ready: "
    PG_READY_OUT=`docker-compose -f $COMPOSE_FILE exec db pg_isready 2>&1`
    PG_READY_STATUS=${PG_READY_OUT:$((${#PG_READY_OUT} - 22)):21}
    if [ "$PG_READY_STATUS" == "accepting connections" ]; then
      echo $PG_READY_STATUS
      break
    else
      PG_READY_STATUS=${PG_READY_OUT:0:18}
      if [ "$PG_READY_STATUS" == "No container found" ]; then
        print_error "The database container isn't running"
      else
        echo "no response"
      fi
      [ $QUERY -eq 10 ] && print_warning "This runs indefinitely, btw."
      QUERY=$(($QUERY + 1))
    fi
  done
}

###
# Run migrations in API container
###
function run_api_migrate {
  docker-compose -f $COMPOSE_FILE run api python ./manage.py migrate
  bail_on_fail $? "API migrations"
}

function create_superuser {
  echo "Use this user to log in at https://api.$CERT_DOMAIN/admin"
  echo "Starting api container..."
  docker-compose -f $COMPOSE_FILE run api python manage.py createsuperuser
  bail_on_fail $? "superuser"
}

###
# iwdlive ./manage
###
check_docker_daemon

if [ "$1" == "mkcert" ]; then
  [ "$2" == "" ] && echo "Please provide a domain name for the certificate!" && exit 1
  make_certificate $2
  exit 0
elif [ "$1" == "init" ]; then
  print_init_steps

  print_banner "?" "Checking parent directory"
  check_empty_parent

  print_banner "?" "Checking Docker version"
  check_docker_version

  print_banner "1" "Cloning API"
  init_api_repo

  print_banner "2" "Cloning PWA"
  init_pwa_repo

  print_banner "3" "Building images"
  build_images

  print_banner "4" "Creating SSL certificate for $CERT_DOMAIN"
  make_certificate $CERT_DOMAIN "init"

  print_banner "~" "Bringing up auxiliary services ($AUX_SERVICES)"
  up_d_services "$AUX_SERVICES"

  # docker reports success as soon as
  # a container is running, but we have to
  # wait for the DB to accept connections
  await_db

  print_banner "5" "Migrating API schemas"
  run_api_migrate

  print_banner "6" "Create django superuser"
  create_superuser

  print_banner "\\\0/" "${COLOR_FG_GREEN}Done"
  echo -e "\nREMEMBER to point $CERT_DOMAIN to 127.0.0.1 in your DNS or hosts file!\n"
  echo "Use './manage up api' to start the api dev server and log in at https://api.$CERT_DOMAIN/admin to create a Caster."
  echo "Then './manage up pwa' to start the React dev server; https://idwlive.dev/(viewer|caster)/{url_path}"
  echo "Both dev servers reload on file changes in their respective repository:"
  echo "  api: $API_REPO_PATH"
  echo "  pwa: $PWA_REPO_PATH"
  exit 0
elif [ "$1" == "down" ]; then
  echo "The 'down' command stops and destroys all containers. THIS WILL WIPE YOUR DATABASE."
  echo "If you just want to stop the services, choose N here and use ./manage stop <services>!"
  read -p "Proceed with destroying all containers? [y/N] " CONTINUE_DOWN
  if [ "$CONTINUE_DOWN" != "y" ]; then exit 0; fi
fi

docker-compose -f $COMPOSE_FILE $@
