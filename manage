#/usr/bin/env bash

# use experimental BuildKit to enable
# --mount at RUN in Dockerfiles, enabling
# caching of pip packages
#  !! Requires Docker v18.09 or later
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1

COMPOSE_FILE="iwdlive-dev_postgres_www.yml"

API_REPO_PATH="../iwdsync-backend"
API_REPO_GIT_DIR="$API_REPO_PATH/.git"
API_REPO_REMOTE="../../stream-sync/iwdsync-backend/.git"

PWA_REPO_PATH="../iwdsync"
PWA_REPO_GIT_DIR="$PWA_REPO_PATH/.git"
PWA_REPO_REMOTE="../../stream-sync/iwdsync/.git"
# branch to check out when cloning API and PWA
GIT_BRANCH="docker-dev"

# Services to build images for
# Essentially all services that have
# a build: entry in the $COMPOSE_FILE
BUILD_IMAGE_FOR="api pwa www"

# Services to run detached, after successful init
AUX_SERVICES="db redis www"
# Domain to set up (used for e.g. SSL certificate)
# REMEMBER to point this to 127.0.0.1 in your DNS or hosts file!
CERT_DOMAIN="iwdlive.dev"

# other settings
COLOR_FG_CYAN="\e[38;5;159m"
COLOR_FG_RED="\e[38;5;196m"
COLOR_FG_YELLOW="\e[38;5;226m"
COLOR_FG_GREEN="\e[38;5;46m"
COLOR_RESET="\e[0m"

function print_init_steps {
  echo "--- iwdlive docker development setup ---"
  echo "This script will"
  echo "  1. Clone the API service ($GIT_BRANCH branch) to $API_REPO_PATH"
  echo "  2. Clone the PWA service ($GIT_BRANCH branch) to $PWA_REPO_PATH"
  echo "  3. Build images ($BUILD_IMAGE_FOR)"
  echo "  4. Create the certificate for $CERT_DOMAIN (requires mkcert)"
  echo "  5. Migrate API db schemas"
  echo -e "----------------------------------------"
  read -p "Key to continue..."
}

function print_banner_border {
  printf '#%.0s' `seq $1`; printf '\n'
}

function print_banner {
  local TITLE="$1 $COLOR_FG_CYAN$2$COLOR_RESET"
  local TITLE_LENGTH=${#TITLE}
  local DIVIDER_LENGTH=$(($TITLE_LENGTH + 4))

  echo ""
  print_banner_border $DIVIDER_LENGTH
  echo -e "# $TITLE"
  print_banner_border $DIVIDER_LENGTH
}

###
# 'mkcert' <DOMAIN>
###
function make_certificate() {
  which mkcert &> /dev/null
  if [ $? -ne 0 ]; then
    echo "You need mkcert for certificate management!"
    echo "Download from: https://github.com/FiloSottile/mkcert"
    [ "$2" != "init" ] && exit 1
  fi

  local DOMAIN=$1
  local OUT_PATH=./www/ssl/$DOMAIN

  mkdir -p $OUT_PATH

  mkcert \
    -key-file $OUT_PATH/key.pem \
    -cert-file $OUT_PATH/cert.pem \
    $DOMAIN *.$DOMAIN
}

###
# pre-run checks
###

function check_docker_daemon {
  docker ps &>/dev/null
  if [ $? -ne 0 ]; then
    print_error "No Docker service running."
    exit 1
  fi
}

function check_empty_parent {
  local HAS_MISC_DIRS=0
  for DIR_NAME in ".."/*; do
    if [ $DIR_NAME != "../docker" ]; then
      HAS_MISC_DIRS=1
      break
    fi
  done

  if [ $HAS_MISC_DIRS -eq 1 ]; then
    print_warning "The parent directory is not empty."
    read -p "Proceed with non-empty parent? [y/N] " USE_NON_EMPTY_PARENT
    if [ "$USE_NON_EMPTY_PARENT" != "y" ]; then exit 0; fi
  fi
}

function check_docker_version {
  local CHECK_FAILED=0
  local MIN_VERSION_MAJOR=18
  local MIN_VERSION_MINOR=09
  local MIN_VERSION="$MIN_VERSION_MAJOR.$MIN_VERSION_MINOR"

  local DOCKER_VERSION=`docker version --format '{{.Server.Version}}'`
  local DOCKER_VERSION_MAJOR=$((${DOCKER_VERSION:0:2}))
  local DOCKER_VERSION_MINOR=$((${DOCKER_VERSION:3:2}))

  echo "  Required: $MIN_VERSION"
  echo "  Installed: $DOCKER_VERSION"

  [ $DOCKER_VERSION_MAJOR -lt $MIN_VERSION_MAJOR ] && \
    CHECK_FAILED=1

  [ $DOCKER_VERSION_MAJOR -eq $MIN_VERSION_MAJOR ] && \
    [ $DOCKER_VERSION_MINOR -lt $MIN_VERSION_MINOR ] && \
      CHECK_FAILED=1

  if [ $CHECK_FAILED -eq 1 ]; then
    print_error "Please upgrade to or install Docker v$MIN_VERSION or later!"
    exit 1
  fi
  echo ""
}

###
# 1. Clone the API service
###
function init_api_repo {
  local GIT_DIR_PATH_ABSOLUTE=`realpath $API_REPO_GIT_DIR 2> /dev/null`
  GIT_DIR=$GIT_DIR_PATH_ABSOLUTE git branch &> /dev/null
  if [[ $? == 0 && $GIT_DIR_PATH_ABSOLUTE != "" ]]; then
    echo "API repo already present at $GIT_DIR_PATH_ABSOLUTE"
  else
    git clone --single-branch -b $GIT_BRANCH $API_REPO_REMOTE $API_REPO_PATH
  fi
}

###
# 2. Clone the PWA service
###
function init_pwa_repo {
  local GIT_DIR_PATH_ABSOLUTE=`realpath $PWA_REPO_GIT_DIR 2> /dev/null`
  GIT_DIR=$GIT_DIR_PATH_ABSOLUTE git branch &> /dev/null
  if [[ $? == 0 && $GIT_DIR_PATH_ABSOLUTE != "" ]]; then
    echo "PWA repo already present at $GIT_DIR_PATH_ABSOLUTE"
  else
    git clone --single-branch -b $GIT_BRANCH $PWA_REPO_REMOTE $PWA_REPO_PATH
  fi
}

###
# 3. Build the images for $BUILD_IMAGE_FOR
###
function build_images {
  docker-compose -f $COMPOSE_FILE build $BUILD_IMAGE_FOR
}

###
# Bring up services detached
###
function up_d_services {
  docker-compose -f $COMPOSE_FILE up -d $1
}

###
# Run migrations in API container
###
function run_api_migrate {
  docker-compose -f $COMPOSE_FILE run api python ./manage.py migrate
}

###
# iwdlive ./manage
###
check_docker_daemon

if [ "$1" == "mkcert" ]; then
  [ "$2" == "" ] && echo "Please provide a domain name for the certificate!" && exit 1
  make_certificate $2
  exit 0
elif [ "$1" == "init" ]; then
  print_init_steps

  print_banner "?" "Checking parent directory"
  check_empty_parent

  print_banner "?" "Checking Docker version"
  check_docker_version

  print_banner "1" "Cloning API"
  init_api_repo

  print_banner "2" "Cloning PWA"
  init_pwa_repo

  print_banner "3" "Building images"
  build_images

  print_banner "4" "Creating SSL certificate for $CERT_DOMAIN"
  make_certificate $CERT_DOMAIN "init"

  print_banner "~" "Bringing up auxiliary services ($AUX_SERVICES)"
  up_d_services "$AUX_SERVICES"

  print_banner "5" "Migrating API schemas"
  run_api_migrate

  print_banner "\\\0/" "${COLOR_FG_GREEN}Done"
  echo "REMEMBER to point $CERT_DOMAIN to 127.0.0.1 in your DNS or hosts file!"
  echo "Use ./manage up (api|pwa) to start the dev servers and go to https://$CERT_DOMAIN"
  echo "Both dev servers reload on file changes in their respective repository:"
  echo "  api: $API_REPO_PATH"
  echo "  pwa: $PWA_REPO_PATH"
  exit 0
elif [ "$1" == "down" ]; then
  echo "The 'down' command stops and destroys all containers. THIS WILL WIPE YOUR DATABASE."
  echo "If you just want to stop the services, choose N here and use ./manage stop <services>!"
  read -p "Proceed with destroying all containers? [y/N] " CONTINUE_DOWN
  if [ "$CONTINUE_DOWN" != "y" ]; then exit 0; fi
fi

docker-compose -f $COMPOSE_FILE $@
